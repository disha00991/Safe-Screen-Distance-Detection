<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opencv JS</title>
    <script async src="./opencv.js" onload="openCvReady();"></script>
    <script src="./utils.js"></script>
</head>

<body>
    <video id="cam_input" height="480" width="640"></video>
    <canvas id="canvas_output"></canvas>
</body>
<script type="text/JavaScript">
function openCvReady() {
  cv['onRuntimeInitialized']=()=>{
    let video = document.getElementById("cam_input"); // video is the id of video tag
    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
    .then(function(stream) {
        video.srcObject = stream;
        video.play();
    })
    .catch(function(err) {
        console.log("An error occurred! " + err);
    });
    let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
    let dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
    let gray = new cv.Mat();
    let cap = new cv.VideoCapture(cam_input);
    let faces = new cv.RectVector();
    let eyes = new cv.RectVector();
    let face_cascade = new cv.CascadeClassifier();
    let eye_cascade = new cv.CascadeClassifier();
    let eyeCascadeFile = 'haarcascade_eye.xml';
    let utils = new Utils('errorMessage');
    let faceCascadeFile = 'haarcascade_frontalface_default.xml'; // path to xml
    utils.createFileFromUrl(faceCascadeFile, faceCascadeFile, () => {
        face_cascade.load(faceCascadeFile); // in the callback, load the cascade from file 
        utils.createFileFromUrl(eyeCascadeFile, eyeCascadeFile, () => {
        eye_cascade.load(eyeCascadeFile); // in the callback, load the cascade from file 
        });
    });


    const FPS = 24;
    const Known_width = 38.1 //cms
    const Known_ipd = 8.03 //cms
    const found_focal_length = 1081.72 // pixels
    
    function processVideo() {
        let begin = Date.now();
        cap.read(src);
        src.copyTo(dst);
        cv.cvtColor(dst, gray, cv.COLOR_RGBA2GRAY, 0);
        try{
            face_cascade.detectMultiScale(gray, faces, 1.1, 3, 0);
            if(faces.size()>0) {
                let first_face = faces.get(0);
                // distance_from_screen = (Known_width * found_focal_length)/first_face.width;
                // console.log("distance from screen: "+distance_from_screen+" cms");
           
                for (let i = 0; i < faces.size(); ++i) {
                    let face = faces.get(i);
                    let point1 = new cv.Point(face.x, face.y);
                    let point2 = new cv.Point(face.x + face.width, face.y + face.height);
                    cv.rectangle(dst, point1, point2, [255, 0, 0, 255]);
                    const face_width_in_frame = face.width;
                    let roiGray = gray.roi(face);
                    let roiSrc = src.roi(face);
                    eye_cascade.detectMultiScale(roiGray, eyes);
                    
                    for (let j = 0; j < eyes.size(); ++j) { //draw rectangle around each eye
                        let point1 = new cv.Point(eyes.get(j).x, eyes.get(j).y);
                        let point2 = new cv.Point(eyes.get(j).x + eyes.get(j).width,
                        eyes.get(j).y + eyes.get(j).height);
                        cv.rectangle(roiSrc, point1, point2, [0, 255, 255, 255]);
                    }
                    let ipd = 0;
                    if(eyes.size() == 2) {
                        ipd = ((eyes.get(0).x - eyes.get(1).x)**2 + (eyes.get(0).y - eyes.get(1).y)**2)**0.5; // find interpupillary distance
                        console.log("ipd: "+ipd+" pixels");
                        distance_from_screen = (Known_ipd * found_focal_length)/ipd;
                        console.log("distance from screen: "+distance_from_screen+" cms");
                    }
                    roiGray.delete(); roiSrc.delete();
                }        

                cv.imshow("canvas_output", src); //show eyes in green box
                // cv.imshow("canvas_output", dst); //show face in red box // not appearing
            }
        } catch(err) {
            console.log(err);
        }
        // schedule next one.
        let delay = 2000;
        setTimeout(processVideo, delay);
    }
// schedule first one.
setTimeout(processVideo, 0);
  };
}
</script>

</html>